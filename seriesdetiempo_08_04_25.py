# -*- coding: utf-8 -*-
"""SeriesDeTiempo 08/04/25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15n6pI6Qm9ezJuwj9k2uIQakwl6s1xPWk
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf

# Define the stocks and date range
tickers = ['COST', 'WMT', 'TGT']
start_date = '2019-01-29'
end_date = '2025-04-08'

# Fetch historical stock data
data = yf.download(tickers, start=start_date, end=end_date, progress=False)['Close']

# Calculate first differences of prices to make them stationary
data_diff = data.diff().dropna()

# Calculate daily returns (for ACF and simulation base)
returns = data.pct_change().dropna()

# Parameters for simulation
n_days = len(data_diff)  # Match the length of differenced data
np.random.seed(42)

# Function to simulate a stationary series (based on differenced prices)
def simulate_stationary_series(initial_diff, returns_mean, returns_std, n_days):
    # Simulate differences instead of cumulative prices
    daily_diffs = np.random.normal(loc=returns_mean, scale=returns_std, size=n_days)
    # Start with the initial difference and add simulated differences
    stationary_path = np.zeros(n_days)
    stationary_path[0] = initial_diff
    for t in range(1, n_days):
        stationary_path[t] = stationary_path[t-1] + daily_diffs[t]
    return stationary_path

# Simulate stationary series for each stock
simulated_paths = {}
for ticker in tickers:
    initial_diff = data_diff[ticker].iloc[0]  # Start with the first difference
    returns_mean = returns[ticker].mean()
    returns_std = returns[ticker].std()
    simulated_paths[ticker] = simulate_stationary_series(initial_diff, returns_mean, returns_std, n_days)

# Convert simulated paths to DataFrame
simulated_df = pd.DataFrame(simulated_paths, index=data_diff.index)

# ADF test function
def adf_test(series, ticker, data_type):
    result = adfuller(series.dropna())
    print(f'\nADF Test for {data_type} of {ticker}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:')
    for key, value in result[4].items():
        print(f'   {key}: {value:.4f}')
    if result[1] < 0.05:
        print(f"Conclusion: Reject the null hypothesis - {data_type} of {ticker} is stationary.")
    else:
        print(f"Conclusion: Fail to reject the null hypothesis - {data_type} of {ticker} is not stationary.")

# Run ADF test on differenced prices and simulated stationary series
for ticker in tickers:
    adf_test(data_diff[ticker], ticker, "Differenced Actual Prices")
    adf_test(simulated_df[ticker], ticker, "Simulated Stationary Series")

# Plotting
plt.figure(figsize=(14, 12))

# Plot 1: Differenced Actual vs Simulated Stationary Series
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 3, i)
    plt.plot(data_diff.index, data_diff[ticker], label=f'{ticker} Differenced Actual', color='blue')
    plt.plot(simulated_df.index, simulated_df[ticker], label=f'{ticker} Simulated Stationary', color='orange', alpha=0.7)
    plt.title(f'{ticker}: Differenced vs Simulated Stationary')
    plt.xlabel('Date')
    plt.ylabel('Price Difference (USD)')
    plt.legend()
    plt.grid(True)

# Plot 2: Correlograms (ACF of Returns)
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 3, i + 3)
    plot_acf(returns[ticker].dropna(), lags=20, ax=plt.gca())
    plt.title(f'{ticker}: ACF of Daily Returns')
    plt.xlabel('Lag')
    plt.ylabel('Autocorrelation')
    plt.grid(True)

# Plot 3: Actual Returns
for i, ticker in enumerate(tickers, 1):
    plt.subplot(3, 3, i + 6)
    plt.plot(returns.index, returns[ticker], color='green', alpha=0.7)
    plt.title(f'{ticker}: Daily Returns')
    plt.xlabel('Date')
    plt.ylabel('Daily Return')
    plt.grid(True)

plt.tight_layout()
plt.show()